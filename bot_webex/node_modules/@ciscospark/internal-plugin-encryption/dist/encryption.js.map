{"version":3,"sources":["encryption.js"],"names":["Encryption","SparkPlugin","extend","children","kms","KMS","namespace","processKmsMessageEvent","event","decryptBinary","scr","buffer","then","b","length","byteLength","reject","Error","decrypt","decryptScr","key","cipherScr","options","getKey","k","SCR","fromJWE","jwk","decryptText","ciphertext","jose","JWE","createDecrypt","result","plaintext","toString","download","loc","shunt","EventEmitter","promise","_fetchDownloadUrl","uri","method","responseType","ret","request","res","body","logger","info","process","env","NODE_ENV","includes","resolve","service","resource","endpoints","url","warn","encryptBinary","file","create","encrypt","ensureBuffer","cdata","encryptScr","toJWE","encryptText","createEncrypt","config","joseOptions","header","alg","reference","final","onBehalfOf","asKey","storageKey","unboundedStorage","get","keyString","JSON","parse","keyObject","catch","fetchKey","put","replacer","v","json","toJSON"],"mappings":"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","file":"encryption.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {SparkPlugin} from '@ciscospark/spark-core';\nimport {proxyEvents, tap, transferEvents} from '@ciscospark/common';\nimport {EventEmitter} from 'events';\nimport jose from 'node-jose';\nimport SCR from 'node-scr';\nimport ensureBuffer from './ensure-buffer';\n\nimport KMS from './kms';\n\nconst Encryption = SparkPlugin.extend({\n  children: {\n    kms: KMS\n  },\n\n  namespace: 'Encryption',\n\n  processKmsMessageEvent(event) {\n    return this.kms.processKmsMessageEvent(event);\n  },\n\n  decryptBinary(scr, buffer) {\n    return ensureBuffer(buffer)\n      .then((b) => {\n        /* istanbul ignore if */\n        if (buffer.length === 0 || buffer.byteLength === 0) {\n          return Promise.reject(new Error('Attempted to decrypt zero-length buffer'));\n        }\n\n        return scr.decrypt(b);\n      });\n  },\n\n  /**\n   * Decrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} cipherScr - An encrypted SCR\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {Object} Decrypted SCR\n   */\n  decryptScr(key, cipherScr, options) {\n    return this.getKey(key, options)\n      .then((k) => SCR.fromJWE(k.jwk, cipherScr));\n  },\n\n  /**\n   * Decrypt text using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} ciphertext - Encrypted text\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Decrypted plaintext\n   */\n  decryptText(key, ciphertext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createDecrypt(k.jwk)\n        .decrypt(ciphertext)\n        .then((result) => result.plaintext.toString()));\n  },\n\n  download(scr) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('`scr.loc` is required'));\n    }\n\n    const shunt = new EventEmitter();\n    const promise = this._fetchDownloadUrl(scr)\n      .then((uri) => {\n        const options = {\n          method: 'GET',\n          uri,\n          responseType: 'buffer'\n        };\n\n        const ret = this.request(options);\n\n        transferEvents('progress', options.download, shunt);\n\n        return ret;\n      })\n      .then((res) => this.decryptBinary(scr, res.body));\n\n    proxyEvents(shunt, promise);\n\n    return promise;\n  },\n\n  _fetchDownloadUrl(scr) {\n    this.logger.info('encryption: retrieving download url for encrypted file');\n\n    if (process.env.NODE_ENV !== 'production' && scr.loc.includes('localhost')) {\n      this.logger.info('encryption: bypassing spark files because this looks to be a test file on localhost');\n\n      return Promise.resolve(scr.loc);\n    }\n\n    return this.request({\n      method: 'POST',\n      service: 'files',\n      resource: 'download/endpoints',\n      body: {\n        endpoints: [\n          scr.loc\n        ]\n      }\n    })\n      .then((res) => {\n        const url = res.body.endpoints[scr.loc];\n\n        if (!url) {\n          this.logger.warn('encryption: could not determine download url for `scr.loc`; attempting to download `scr.loc` directly');\n\n          return scr.loc;\n        }\n        this.logger.info('encryption: retrieved download url for encrypted file');\n\n        return url;\n      });\n  },\n\n  encryptBinary(file) {\n    return ensureBuffer(file)\n      .then((buffer) => SCR.create()\n        .then((scr) => scr.encrypt(buffer)\n          .then(ensureBuffer)\n          // eslint-disable-next-line max-nested-callbacks\n          .then((cdata) => ({scr, cdata}))));\n  },\n\n  /**\n   * Encrypt a SCR (Secure Content Resource) using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {Object} scr - Plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted SCR\n   */\n  encryptScr(key, scr, options) {\n    /* istanbul ignore if */\n    if (!scr.loc) {\n      return Promise.reject(new Error('Cannot encrypt `scr` without first setting `loc`'));\n    }\n\n    return this.getKey(key, options)\n      .then((k) => scr.toJWE(k.jwk));\n  },\n\n  /**\n   * Encrypt plaintext using the supplied key uri.\n   *\n   * @param {string} key - The uri of a key stored in KMS\n   * @param {string} plaintext\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Encrypted text\n   */\n  encryptText(key, plaintext, options) {\n    return this.getKey(key, options)\n      .then((k) => jose.JWE\n        .createEncrypt(this.config.joseOptions, {\n          key: k.jwk,\n          header: {\n            alg: 'dir'\n          },\n          reference: null\n        })\n        .final(plaintext, 'utf8'));\n  },\n\n  /**\n   * Fetch the key associated with the supplied KMS uri.\n   *\n   * @param {string} uri - The uri of a key stored in KMS\n   * @param {Object} options\n   * @param {string} options.onBehalfOf - Fetch the KMS key on behalf of another user (using the user's UUID), active user requires the 'spark.kms_orgagent' role\n   * @returns {string} Key\n   */\n  getKey(uri, {onBehalfOf} = {}) {\n    if (uri.jwk) {\n      return this.kms.asKey(uri);\n    }\n\n    let storageKey = uri;\n\n    if (onBehalfOf) {\n      storageKey += `/onBehalfOf/${onBehalfOf}`;\n    }\n\n    return this.unboundedStorage.get(storageKey)\n      .then((keyString) => JSON.parse(keyString))\n      .then((keyObject) => this.kms.asKey(keyObject))\n      .catch(() => this.kms.fetchKey({uri, onBehalfOf})\n        .then(tap((key) => this.unboundedStorage.put(storageKey, JSON.stringify(key, replacer)))));\n  }\n});\n\n/**\n * JSON.stringify replacer that ensures private key data is serialized.\n * @param {string} k\n * @param {mixed} v\n * @returns {mixed}\n */\nfunction replacer(k, v) {\n  if (k === 'jwk') {\n    // note: this[k] and v may be different representations of the same value\n    // eslint-disable-next-line no-invalid-this\n    const json = this[k].toJSON(true);\n\n    return json;\n  }\n\n  return v;\n}\n\nexport default Encryption;\n"]}