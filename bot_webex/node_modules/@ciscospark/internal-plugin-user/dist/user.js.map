{"version":3,"sources":["user.js"],"names":["User","SparkPlugin","extend","keyFactory","email","options","String","create","namespace","children","batcher","UserUUIDBatcher","props","hasPassword","default","type","session","store","UserUUIDStore","activate","verificationToken","confirmationCode","id","reject","Error","spark","config","credentials","federation","scope","needsCILookup","getUserCI","then","activateOptions","request","uri","activationUrl","method","body","auth","user","client_id","pass","client_secret","sendImmediately","res","set","supertoken","tokenData","asUUID","all","map","u","_extractUUID","force","patterns","uuid","test","resolve","_extractEmailAddress","getUUID","fetchUUID","recordUUID","emailAddress","get","service","resource","getByEmail","userExists","catch","initialize","args","prototype","add","register","verify","setPassword","password","getUserToken","token","setPasswordUrl","internal","device","userId","headers","authorization","toString","schemas","update","displayName","verifyDefaults","orgIdentityUrl","identity","url","orgIdbrokerUrl","idbroker","defaultUrl","getClientToken","preloginId","shouldRefreshAccessToken","sso","userEntities","idBrokerUrl","identityUrl","reason","lookupCI","verifyOptions","suppressEmail","entryUUID","entryEmail"],"mappings":"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","file":"user.js","sourcesContent":["/*!\n * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\nimport {deprecated, oneFlight, patterns, tap} from '@ciscospark/common';\nimport {persist, SparkPlugin, waitForValue} from '@ciscospark/spark-core';\n\nimport UserUUIDBatcher from './user-uuid-batcher';\nimport UserUUIDStore from './user-uuid-store';\n\n/**\n * @class\n */\nconst User = SparkPlugin.extend({\n  namespace: 'User',\n\n  children: {\n    batcher: UserUUIDBatcher\n  },\n\n  props: {\n    /**\n     * Indicates if the current user is known to have a password.\n     * @instance\n     * @memberof User\n     * @type {boolean}\n     */\n    hasPassword: {\n      default: false,\n      type: 'boolean'\n    }\n  },\n\n  session: {\n    store: {\n      default() {\n        return new UserUUIDStore();\n      },\n      type: 'any'\n    }\n  },\n\n  @waitForValue('@')\n  /**\n   * Activates a Spark user account and exchanges for user token.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {Object} options.confirmationCode (required -- optional if verification token is provided)\n   * @param {Object} options.id (required -- optional if verification token is provided)\n   * @param {Object} options.verificationToken (required -- optional if uuid and verification token provided)\n   * @param {Object} options.email (required with verificationToken for Federation/global user)\n   * @returns {Promise} Resolves with a userSession\n   */\n  activate(options = {}) {\n    if (!(options.verificationToken || (options.confirmationCode && options.id))) {\n      return Promise.reject(new Error('either options.verificationToken is required or both options.confirmationCode and options.id are required'));\n    }\n\n    // Email is required for federation\n    if (this.spark.config.credentials.federation && !options.email) {\n      return Promise.reject(new Error('email is required with federation option'));\n    }\n\n    options.scope = this.spark.config.credentials.scope;\n\n    // if we have options.email and options.verificationToken\n    // and Federation flag is enabled, flag that we need to\n    // lookup user's CI.\n    const needsCILookup = this.spark.config.credentials.federation && options.email && options.verificationToken;\n\n    return this.getUserCI(options.email, needsCILookup).then(() => {\n      const activateOptions = Object.assign({}, options);\n\n      delete activateOptions.email;\n\n      return this.request({\n        uri: this.spark.config.credentials.activationUrl,\n        method: 'POST',\n        body: activateOptions,\n        auth: {\n          user: this.spark.config.credentials.client_id,\n          pass: this.spark.config.credentials.client_secret,\n          sendImmediately: true\n        }\n      })\n        .then((res) => {\n          this.spark.credentials.set({supertoken: res.body.tokenData});\n\n          return res.body;\n        });\n    });\n  },\n\n  /**\n   * Converts a user-identifying object to a uuid, perhaps by doing a network\n   * lookup\n   * @param {string|Object} user\n   * @param {Object} options\n   * @param {boolean} options.create if true, ensures the return UUID refers to\n   * an existing user (rather than creating one deterministically based on email\n   * address), even if that user must be created\n   * @returns {Promise<string>}\n   */\n  asUUID(user, options) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (isArray(user)) {\n      return Promise.all(user.map((u) => this.asUUID(u, options)));\n    }\n\n    const id = this._extractUUID(user);\n\n    if (!(options && options.force) && patterns.uuid.test(id)) {\n      return Promise.resolve(id);\n    }\n\n    const email = this._extractEmailAddress(user);\n\n    if (!patterns.email.test(email)) {\n      return Promise.reject(new Error('Provided user object does not appear to identify a user'));\n    }\n\n    return this.getUUID(email, options);\n  },\n\n  /**\n   * Requests a uuid from the api\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  fetchUUID(email, options) {\n    return this.batcher.request({\n      email,\n      create: options && options.create\n    })\n      .then((user) => this.recordUUID(Object.assign({emailAddress: email}, user))\n        .then(() => user.id));\n  },\n\n  /**\n   * Fetches details about the current user\n   * @returns {Promise<Object>}\n   */\n  get() {\n    return this.request({\n      service: 'conversation',\n      resource: 'users'\n    })\n      .then((res) => res.body)\n      .then(tap((user) => this.recordUUID({\n        id: user.id,\n        // CI endpoints don't use the same user format as actors, so, email may\n        // be in one of a few fields\n        emailAddress: user.email || user.emailAddress\n      })));\n  },\n\n  /**\n   * Converts an email address to a uuid, perhaps by doing a network lookup\n   * @param {string} email\n   * @param {Object} options\n   * @param {boolean} options.create\n   * @returns {Promise<string>}\n   */\n  @oneFlight({keyFactory: (email, options) => email + String(options && options.create)})\n  getUUID(email, options) {\n    return this.store.getByEmail(email)\n      .then((user) => {\n        if (options && options.create && !user.userExists) {\n          return Promise.reject(new Error('User for specified email cannot be confirmed to exist'));\n        }\n\n        if (!user.id) {\n          return Promise.reject(new Error('No id recorded for specified user'));\n        }\n\n        return user.id;\n      })\n      .catch(() => this.fetchUUID(email, options));\n  },\n\n  @persist('@')\n  initialize(...args) {\n    return Reflect.apply(SparkPlugin.prototype.initialize, this, args);\n  },\n\n  /**\n   * Caches the uuid for the specified email address\n   * @param {Object} user\n   * @param {string} user.id\n   * @param {string} user.emailAddress\n   * @returns {Promise}\n   */\n  recordUUID(user) {\n    if (!user) {\n      return Promise.reject(new Error('`user` is required'));\n    }\n\n    if (!user.id) {\n      return Promise.reject(new Error('`user.id` is required'));\n    }\n\n    if (!patterns.uuid.test(user.id)) {\n      return Promise.reject(new Error('`user.id` must be a uuid'));\n    }\n\n    if (!user.emailAddress) {\n      return Promise.reject(new Error('`user.emailAddress` is required'));\n    }\n\n    if (!patterns.email.test(user.emailAddress)) {\n      return Promise.reject(new Error('`user.emailAddress` must be an email address'));\n    }\n\n    return this.store.add(user);\n  },\n\n  @deprecated('Use User#verify()')\n  register(...args) {\n    return this.verify(...args);\n  },\n\n  /**\n   * Updates a user's password with spark.\n   * @instance\n   * @memberof User\n   * @param {Object} options\n   * @param {string} options.password (required)\n   * @param {string} options.email (required when federation enabled)\n   * @returns {Promise} Resolves with complete user object containing new password\n   */\n  setPassword(options) {\n    options = options || {};\n    if (!options.password) {\n      return Promise.reject(new Error('`options.password` is required'));\n    }\n\n    // Email is required for federation\n    if (this.spark.config.credentials.federation && !options.email) {\n      return Promise.reject(new Error('email is required with federation option'));\n    }\n\n    return this.getUserCI(options.email, this.spark.config.credentials.federation)\n      .then(() => this.spark.credentials.getUserToken())\n      .then((token) => this.request({\n        uri: `${this.spark.config.credentials.setPasswordUrl}/${this.spark.internal.device.userId}`,\n        method: 'PATCH',\n        headers: {\n          authorization: token.toString()\n        },\n        body: {\n          schemas: ['urn:scim:schemas:core:1.0', 'urn:scim:schemas:extension:cisco:commonidentity:1.0'],\n          password: options.password\n        }\n      }))\n      .then((res) => {\n        this.hasPassword = true;\n\n        return res.body;\n      });\n  },\n\n  /**\n   * Updates the current user's display name\n   * @param {Object} options\n   * @param {string} options.displayName\n   * @returns {Promise<Object>}\n   */\n  update(options) {\n    options = options || {};\n    if (!options.displayName) {\n      return Promise.reject(new Error('`options.displayName` is required'));\n    }\n\n    return this.request({\n      method: 'PATCH',\n      service: 'conversation',\n      resource: 'users/user',\n      body: options\n    })\n      .then((res) => res.body);\n  },\n\n  /**\n   * Determines if the specified user needs to signup or can signin.\n   * Triggers activation email if client credentials are used\n   * @param {Object} options\n   * @param {string} options.email (required)\n   * @param {string} options.reqId required if need to check email status\n   * @param {string} options.preloginId\n   * @returns {Promise<Object>}\n   */\n  verify(options) {\n    options = Object.assign({}, this.config.verifyDefaults, options);\n    if (!options.email) {\n      return Promise.reject(new Error('`options.email` is required'));\n    }\n\n    // For Federation, there is only one Atlas, which we get the user's CI from\n    // Use default CI URL to start, will be re-set after we retrieve user's CI\n    const orgIdentityUrl = this.spark.config.credentials.identity.url;\n    const orgIdbrokerUrl = this.spark.config.credentials.idbroker.url;\n\n    if (this.spark.config.credentials.federation) {\n      this.spark.config.credentials.idbroker.url = this.spark.config.credentials.idbroker.defaultUrl;\n      this.spark.config.credentials.identity.url = this.spark.config.credentials.identity.defaultUrl;\n    }\n\n    return this.spark.credentials.getUserToken()\n      .catch(() => this.spark.credentials.getClientToken())\n      .then((token) => this.request({\n        service: 'atlas',\n        resource: 'users/activations',\n        method: 'POST',\n        headers: {\n          authorization: token.toString(),\n          'x-prelogin-userid': options.preloginId\n        },\n        body: options,\n        shouldRefreshAccessToken: false\n      }))\n      .then((res) => {\n        if (res.body.hasPassword || res.body.sso) {\n          this.hasPassword = true;\n        }\n\n        // if we have a different CI than default, and Federation is enabled,\n        // update the CI to what was returned by Atlas.\n        if (this.spark.config.credentials.federation && res.body.userEntities) {\n          this.spark.config.credentials.idbroker.url = res.body.userEntities.idBrokerUrl;\n          this.spark.config.credentials.identity.url = res.body.userEntities.identityUrl;\n        }\n\n        return res.body;\n      })\n      .catch((reason) => {\n        // reset CI on failure\n        if (this.spark.config.credentials.federation) {\n          this.spark.config.credentials.idbroker.url = orgIdbrokerUrl;\n          this.spark.config.credentials.identity.url = orgIdentityUrl;\n        }\n\n        return Promise.reject(reason);\n      });\n  },\n\n\n  /**\n   * If the passed-in lookupCI is true, retrieve the user's\n   * CI from Atlas and return the URL's via a Promise.\n   * Otherwise, return current CI in config via a Promise.\n   * Useful in a Promise chain to retrieve the CI based on\n   * conditions like Federation enabled, and suppresses sending\n   * an additional email to the user, since this is just a\n   * look-up.\n   * @param {string} email (required)\n   * @param {boolean} lookupCI (required)\n   * @returns {Promise<Object>}\n   */\n  getUserCI(email, lookupCI) {\n    if (lookupCI) {\n      // call verify first to get the user's CI, but suppress sending another email\n      const verifyOptions = {\n        email,\n        suppressEmail: true\n      };\n\n      return this.verify(verifyOptions).then((res) => Promise.resolve(res.userEntities));\n    }\n\n    return Promise.resolve(\n      {\n        idBrokerUrl: this.spark.config.credentials.idbroker.url,\n        identityUrl: this.spark.config.credentials.identity.url\n      }\n    );\n  },\n\n  /**\n   * Extracts the uuid from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractUUID(user) {\n    return user.entryUUID || user.id || user;\n  },\n\n  /**\n   * Extracts the email address from a user identifying object\n   * @param {string|Object} user\n   * @private\n   * @returns {string}\n   */\n  _extractEmailAddress(user) {\n    return user.email || user.emailAddress || user.entryEmail || user;\n  }\n\n});\n\nexport default User;\n"]}